---
layout: post
title: "Vala: using localization and build-time options"
categories: vala
---

This post is intended as a guide for those who

* Want to pass data at build time to their Vala project
* Want to use gettext in their Vala project

<!--more-->

I haven't found any existing tutorials on this matter, so I've decided to make one myself.

For the purpose of this article, I'll assume you're using [Meson build system](https://mesonbuild.com) - it's a de-facto standard among Vala projects and is pretty nice overall. Additionally, it makes build-side gettext setup very easy.

* TOC
{:toc}

## Build-time options in Vala

Due to its transpiled nature, Vala technically has *two* preprocessors:

* Vala's [own preprocessor](https://wiki.gnome.org/Projects/Vala/Manual/Preprocessor), which is limited to simple boolean toggles and is called before and parsing takes place. Toggles can *only* be set by passing `-D TOGGLE_NAME` to Valac (via `vala_args` in meson) and never appear in generated output.
* C's far more complex preprocessor that works on transpiled code. It is partially exposed in Vala as `const`/`extern const` modifier. These can be either defined in headers or passed via command line (`c_args` in meson).

This leads to roughly three possible use cases for a build-time setting:

### Toggleable feature of your program

For example, your program can use some support library, but also can work without it being present. This is best handled by using Vala's preprocessor, since it will make Valac completely skip lookup of missing symbols. For example:

```meson
extra_vala_args = []

myproject_deps = [
  ...
]

libportal = dependency('libportal', required: get_option('libportal'))
libportal_gtk4 = dependency('libportal-gtk4', required: get_option('libportal'))

if (libportal.found() and libportal_gtk4.found())
  myproject_deps += [libportal, libportal_gtk4]
  extra_vala_args += ['-D', 'WITH_LIBPORTAL']
endif

executable('myproject',
  ...
  dependencies: myproject_deps,
  vala_args: extra_vala_args,
  ...
)
```

Then in your Vala files:

```vala
#if WITH_LIBPORTAL
	// use libportal routines
#else
	// use native routines
#endif
```

An additional handy trick for the case where library may be present at compile time but you still want to use library-free path under some conditions:

```vala
#if WITH_LIBPORTAL
	if (Xdp.portal.running_under_sandbox()) {
		// Use libportal
	} else
#endif
	{
		// Use native implementation
	}
```

### Build-time value

The most common case is passing installation directory paths or version values, but it has other uses too. Vala's own preprocessor won't do here due to being limited to toggles. Luckily, meson's own [configuration system](https://mesonbuild.com/Configuration.html) comes in to save the day:

```meson
conf_data = configuration_data()

conf_data.set_quoted('MYPRJ_VERSION',    meson.project_version())
conf_data.set_quoted('MYPRJ_LOCALE_DIR', get_option('prefix') / get_option('localedir'))

configure_file(
  output: 'config.h',
  configuration: conf_data
)
```

This will generate `config.h` header with `#define`s for `MYPRJ_VERSION` and `MYPRJ_LOCALE_DIR` as strings. Meson is kind enough to let us run without an input template header file, which is super handy in Vala's case.

Note that you should change `MYPRJ` prefix to something more relevant to your project. Dropping it entirely is an option too, but beware name clashes with other libraries.

Now, it's time to expose those defines to Vala! There are a few ways to do this, but the best one is most definitely to create a separate file `config.vapi` (add it as a source file in meson!) with the following contents:

```vala
// Defined in config.h generated by meson
// lower_case_cprefix is required even if unused in practice
[CCode (cprefix = "MYPRJ_", lower_case_cprefix = "myprj_", cheader_filename = "config.h")]
namespace BuildConfig {
	public const string VERSION;
	public const string LOCALE_DIR;
}
```

Then reference those constants like any other from within your program:

```vala
print("Program version: %s\n", BuildConfig.VERSION);
```

### Values used by included libraries

The most annoying case which, fortunately, comes up fairly rarely. It is when some other library expects C defines to be present at build time; the most common cases being `G_LOG_DOMAIN` and `GETTEXT_PACKAGE`.

Ideally, one would pass them the same way as other build-time values. Unfortunately, there is no way to force Vala to include your `config.h` before headers that use those defines. This means that the only way to pass this kind of settings is by using `c_args` in meson:

```
executable('myproject',
  ...
  c_args: [
    # These must be defined before GLib includes
    '-DGETTEXT_PACKAGE="myproject"',
    '-DG_LOG_DOMAIN="myproject"',
  ],
  ...
)
```

It's often handy to have them exposed in Vala as well. Add the following to `config.vapi` from the previous section (or create and add it as a source file in meosn if you don't already have it):

```vala
// Passed via c_args
[CCode (cprefix = "", lower_case_cprefix = "")]
namespace BuildCArgs {
	public const string GETTEXT_PACKAGE;
	public const string G_LOG_DOMAIN;
}
```

Using a namespace is not required, but great for clarity. Once again, access like any other variable:

```vala
print("Current log domain: %s\n", BuildCArgs.G_LOG_DOMAIN);
```

## Adding gettext support

### Translation directory setup

Gettext support requires a bit of extra effort on build system side. Default project in Gnome Builder will already set basics up, but here's a more detailed explanation of files and what they do.

All localization files should live in a separate directory, typically called `po`. It should include the following files:

#### `meson.build`
```meson
i18n = import('i18n')
i18n.gettext('myproject', preset: 'glib')
```

First line is not needed if already present in top-level meson file. This allows to call `subdir('po')` from top-level meson file. `myproject` here stands for *translation domain*. It generally should be the name of your project.

#### `LINGUAS`

A list of language codes your application supports sans one used for source strings, one per line. Determines what `.po` files will be generated/updated. Can be left empty at the beginning.

#### `POTFILES`

A list of files containing translatable strings, relative to project's top directory. Has to be kept up-to-date manually and should include **both source and data (e.g. desktop and appstream) files**.

A handy command for listing all your source files in a Vala+Blueprint project, can be adjusted as needed:

```bash
find src/ -type f \( -name '*.vala' -or -name '*.blp' \)
```

#### `<translation domain>.pot`

A generated file that serves as the template for `.po` files. Should never be edited manually. Updated by building target `<translation domain>-pot`; this will overwrite the file completely.

#### `<language code>.po`

Individual translation files, edited by your localization team. Updated using target `<translation domain>-update-po` (which will automatically update `.pot` file as well); this will retain existing translations.

### Vala setup

Read the section on passing build-time options first. You'll have to set `GETTEXT_DOMAIN` using `c_args` and pass locale dir via `config.h`. That done, loading gettext is super easy; just add the following at the beginning of your `main` function:

```vala
Intl.setlocale();
Intl.bindtextdomain(BuildCArgs.GETTEXT_PACKAGE, BuildConfig.LOCALE_DIR);
Intl.bind_textdomain_codeset(BuildCArgs.GETTEXT_PACKAGE, "UTF-8");
Intl.textdomain(BuildCArgs.GETTEXT_PACKAGE);
```

Alternatively, if you're writing a library, call this in your library initialization function/module entry point:

```
Intl.bindtextdomain(BuildCArgs.GETTEXT_PACKAGE, BuildConfig.LOCALE_DIR);
Intl.bind_textdomain_codeset(BuildCArgs.GETTEXT_PACKAGE, "UTF-8");
```

That's it, you now have localization set up! Make sure to update po/pot files using respective meson targets when you make changes to translatable strings and to keep `POTFILES` up-to-date.

As an aside, calling `Intl.setlocale();` at the beginning of your program is generally a good idea: without it, `print` won't actually output unicode characters.

### Extra: a short introduction to gettext functions

#### `_`

```vala
_("Translatable string")
```

The simplest version: just translates string outright. Different invocations with the same string will be translated the same way.

The passed argument *should* be a string literal; otherwise, it won't be extracted for translation. f-strings strings are not i18n-friendly; use the following instead:

```vala
_("Arguments: %i; %s").printf(5, "hi")
```

#### `C_`

```vala
C_("context", "Translatable string")
C_("other context", "Translatable string")
```

String with a context: same string with different contexts can be translated differently. A possible example would be opening a file vs opening a printer.

This function's arguments *must* be string literals/constants or C compilation will fail.

#### `N_` and `NC_`

Identical to their non-N-prefixed counterparts, but do not actually perform translation by themselves (call `_` and `dpgettext2` respectively on their results). They should be used when multiple strings are loaded but only few resolved, like array initialization. You'll rarely need them.
